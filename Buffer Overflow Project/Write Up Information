In terminal we need to understand where the buffer that is being exploited is. To do this we will use a few simple commands in gdb. First we must load gdb and the file that we would like to examine. This is done by using "gdb vuln". Once we have vuln loaded into gdb we can examine symbols from vuln, for example, we can call "disas main" which allows us to view the assembly code of the main function. The important thing to note here is that the vulnerability lies within the function of exploitable, we will inspect that by calling "disas exploitable". 

As we view the function exploitable, we need to pay attention to where the call is happening. It is being addressed as such: 
 0x0000000000001206 <+45>:	call   0x1070 <strcpy@plt>
We can then add a breakpoint in the file to determine some important details. I will add a break to 0x000000000000120b, which is immediately after the call. However, I ran into an issue because of the ASLR (Address space layout randomization). This meant I had to determine where the program was beginning at. After doing some research I discovered "info proc mappings", which allowed me to see where the program was being held in memory. With this information I was able to provide an offset. I knew that I would need to use 0x120b with the entry address which was 0x400000. Now I could index a break point by using both of these values as 0x40120b.

There was still an issue regarding stack smashing and I needed to resolve it somehow. After researching how to disable stack smashing in gcc, I saw that I could use "gcc vuln.c -o vuln -fno-stack-protector", which compiles the programming without the flag. As I've worked through it a bit deeper, there seems to be an issue with permissions, for awhile I was running into a SIGSEGV fault. From the way it looks this is something that could be disabled and I went into the root of the system and called "echo 0 > /proc/sys/debug/exception-trace" which allowed for the error to be ignored. However, during this time I also noticed that the programmed recompiled to new addresses, this is because I disabled the stack smashing and as a result the recompiled program was slightly shifted. In the current iteration I am working on after calling info proc mappings, I see that the offset is now 0x11c5, rather than 0x120b. To test if I was able to move through both of the errors I was getting I used "run $(python3 -c "print('A' * 256)")" in gdb, and it seems to be working. 

An error kept popping up that said it could not access the memory address so I examined the info registers to see where the stack point register was located. I noticed that it was different from the typical esp. This is because of the 64-bit system, a 32-bit system uses esp, whereas 64-bit uses rsp for stack pointing. With this information I can see that the stack begins at address 0x7fffffffdba8. After reenabling the segmentation fault, I noticed that it was occurring in the return address in exploitable. 

Still having issues, will need to do more research and see why I cannot get beyond the return, of if I should be looking to execute my code there. Although, I did just notice that my call to run the program edited the rbp register, this may be something to looking into and messing with the amount of values that I'm copying. I've noticed that the value in rbp starts to change when we do: run $(python3 -c "print('A' * 12)") and it results in the last 4 elements of the address to be "4141". This may help in entering the shell. 