- Details regarding exam: 
	- on Thursday, at 11AM
	- 1 hour and 15 minutes
	- need a computer 
	- We can have two pages of typed notes (can be anything) front and back
	- format will be mpq (70-75%) and short answer (25-30%) 
	- should know how RSA and Diffie-Helman are computed 
	- Chapters 1, 2, 20, and 21 
	- reading questions are a good resource 
	- No mode of operations
	- strong collision we know that it will happen, weak means it may happen but not a large concern 
	- maybe a substitution cipher that needs to be taken care of 
	- ECB and Counter are the modes of operations we should know about 
		- ECB was like rolling pad cipher, you use your pad and for every letter you have in your message you offset. Never reuse the previous information when given a new message
		- ECB has a huge file and deletes anything previously used, must convert by doing a weak scramble, making it less likely to find a pattern 
		- Counter uses some value as an offset for each block, we use XOR keeping track of every block and using the counter to scramble each block 
		- only meant to add extra complexity 
	- CIA triad: balance of how software should be maintained in terms of security
		- Confidentiality: secret
		- Integrity: validation
		- Accessibility: access
	- DES is easy to break with modern computing
	- 3 DES is a loss of speed and need a new key for each iteration. These keys are not replaced, and this degrades the algorithm because we have key pairings
	- Digital signature: hashed validation of a message, allows us the message has not been tampered with, we can use the public key to reproduce the signature to confirm. Uses a private and public key 
	- Public-Key: 
	- Write out an attack tree: we provide all the possible branches of an attack

- Random number generation: 
	- Criteria: 
		- uniform distribution 
			- frequency of individual number's occurrence should be approximately the same 
		- independence: 
			- No one value from the sequence can be inferred from another 
	- random numbers are like side affects
	- in linux, dev/ran uses the kernel garbage to create random numbers 
	- Random numbers are generated by seeds and use tables, in computing we can only have pseudorandom numbers 
